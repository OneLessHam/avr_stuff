/* ----------------------------------------------------------------------- */
/* Template source file generated by piklab */
#include <pic16f877a.h>

/* ----------------------------------------------------------------------- */
/* Configuration bits: adapt to your setup and needs */
typedef unsigned int word;
word at 0x2007 CONFIG = _RC_OSC & _WDT_OFF & _PWRTE_ON & _BODEN_OFF & _LVP_OFF & _CPD_OFF & _WRT_OFF & _DEBUG_OFF & _CP_OFF;

// how do you officially define binary data in sdcc?
// this should work in any compiler
#define BIN(x) \
( ((0x##x##L & 0x00000001L) ? 0x01 : 0) \
| ((0x##x##L & 0x00000010L) ? 0x02 : 0) \
| ((0x##x##L & 0x00000100L) ? 0x04 : 0) \
| ((0x##x##L & 0x00001000L) ? 0x08 : 0) \
| ((0x##x##L & 0x00010000L) ? 0x10 : 0) \
| ((0x##x##L & 0x00100000L) ? 0x20 : 0) \
| ((0x##x##L & 0x01000000L) ? 0x40 : 0) \
| ((0x##x##L & 0x10000000L) ? 0x80 : 0))

#define set_bit(REGISTER, BIT) REGISTER |= (1 << BIT)

void disp_set_num(unsigned long val);
void disp_set_num_raw(int val);
void disp_set_decimal_places(unsigned char decimals);
void disp_kilo();
void disp_dig(unsigned char d);
void disp_disp();

// holds the magic numbers required to spell out each digit
// on the LED display.
char sseg[10] = {
//	    .gfedcba
	BIN(00111111),		// 0
	BIN(00000110),		// 1
	BIN(01011011),		// 2
	BIN(01001111),		// 3
	BIN(01100110),		// 4
	BIN(01101101),		// 5
	BIN(01111101),		// 6
	BIN(00000111),		// 7
	BIN(01111111),		// 8
	BIN(01101111)		// 9
};

// I haven't tried changing this yet.
#define DISP_SIZE (4)

// set these to calibrate the final output power reading
// CALIBRATION_OFFSET will be added to the final after dividing the
// unscaled raw value by 1000 and then multiplying by 
// CALIBRATION_SCALE.  This is to allow some fractional constants
// without going back and forth between floating point and int
// types.  This will work as long as the power doesn't exceed
// 2^32/1000000 = 4294 watts.  Otherwise change it to a scale of
// 100 or the way this is done.
#define CALIBRATION_OFFSET ( -35 )
// #define CALIBRATION_SCALE ( 0.598476f )
// #define CALIBRATION_SCALE ( 598 )
#define CALIBRATION_SCALE ( 1671 )

unsigned char dispsize = 0;
unsigned char dispdig[5];
unsigned char dot_after = 0;
unsigned char kilo = 0;

unsigned int reference = 1;
unsigned int current = 2;
unsigned int current_diff = 12;
unsigned long current_max = 0;
unsigned int voltage = 4;
unsigned int voltage_diff = 13;
unsigned long voltage_max = 0;

// each of these correspond to one of the modes the mode knob
// could be in.  If mode1 is selected, the value in mode1 is
// displayed on the LED display.
unsigned long mode1 = 1;
unsigned long mode2 = 2;
unsigned long mode3 = 3;
unsigned long mode4 = 4;
unsigned long mode5 = 5;
unsigned long mode6 = 6;
unsigned long mode7 = 7;
unsigned long mode8 = 8;

// data to keep moving averages of watts.  Input values are the
// result data from an analyze call
#define MOVING_AVG_SIZE (5)
unsigned long moving_avg[MOVING_AVG_SIZE];
unsigned long moving_avg_total = 0;
unsigned char moving_avg_i = 0;

// totals used to sum per sample values
unsigned long total1 = 0;
unsigned long total_cnt = 0;

// the primary display function. sets the number to display
// use disp_disp() to actually light up the display
// displays val / 1000, or thousandths.
// displayed number can be in the range of [0.001, 99999999.9999]
// WARNING: doesn't obey DISP_SIZE
void disp_set_num(unsigned long val)
{
	if(val < 10000L) {
		disp_set_num_raw(val);
		disp_set_decimal_places(3);
		kilo = 0;
	} else if(val < 100000L) {
		disp_set_num_raw(val/10L);
		disp_set_decimal_places(2);
		kilo = 0;
	} else if(val < 1000000L) {
		disp_set_num_raw(val/100L);
		disp_set_decimal_places(1);
		kilo = 0;
	} else if(val < 10000000L) {
		disp_set_num_raw(val/1000L);
		disp_set_decimal_places(0);
		kilo = 0;
	} else if(val < 100000000L) {
		disp_set_num_raw(val/10000L);
		disp_set_decimal_places(2);
		kilo = 1;
	} else if(val < 1000000000L) {
		disp_set_num_raw(val/100000L);
		disp_set_decimal_places(1);
		kilo = 1;
	} else if(val < 0xFFFFFFFF) {
		disp_set_num_raw(val/1000000L);
		disp_set_decimal_places(0);
		kilo = 1;
	}
}

// dispalys the int val.  No scaling is performed.
void disp_set_num_raw(int val)
{
        char i = DISP_SIZE;

        while(val != 0)
        {
                dispdig[i--] = val % 10;
                val = val / 10;
        }
        while(i != 0)
        {
                dispdig[i--] = 0;
        }

        dispsize = i;
}

// set the number of decimal places visible.
// decimals can be in the range of [0, DISP_SIZE]
void disp_set_decimal_places(unsigned char decimals) {
	dot_after = DISP_SIZE - decimals;
}

// update the kilo LED
// TODO: use defines or constants to set which PORT/pin is used
void disp_kilo() {
	if(kilo) {
		PORTC = 0x01;
	} else {
		PORTC = 0x00;
	}
}

// display a single digit
//  valid digits are from [1, DISP_SIZE+1]
//  use this if you would like to display numbers while doing other
//  computations.
// dig_pins sets the pins used to select each digit.  See LED display in docs
unsigned char dig_pins[4] = {0x01, 0x02, 0x08, 0x10};
void disp_dig(unsigned char d) {
	unsigned int i;
	PORTB = 0xFF;
	i = d - 1;
	PORTD = dig_pins[i];
	PORTB = ~sseg[dispdig[d]];
	if(d == dot_after) {
		PORTB &= 0x7F;
	}
}

// display the entire number.
// TODO: allow an optional delay to be inserted between each digit to decrease
// the PWM frequency.
void disp_disp() {
	// d = dispsize;
	unsigned char d = 0;
	unsigned int i = 0;
	
	disp_kilo();

	for(i = 1; i <= DISP_SIZE; ++i) {
		disp_dig(i);
	}
}

////////////////////////////////////////////////////////////////////////////////
//
//   ADC
//
////////////////////////////////////////////////////////////////////////////////

// wait for a conversion to complete
void adc_wait(){
	while(ADCON0 & 0x04) { }
}

// count to n
void delay(unsigned int n) {
	unsigned int i;
	for(i = 0; i < n; ++i) {}
}

// turn on the adc module
void adc_on() {
	_asm
	BSF ADCON0, 0;
	_endasm;
}

// turn off the adc module
void adc_off() {
	_asm
	BCF ADCON0, 0;
	_endasm;
}

// set the adc clock.
// 
void adc_set_clock(unsigned char clk) {
	if(clk & 0x01) {
		_asm BSF ADCON0, 6 _endasm;
	} else {
		_asm BCF ADCON0, 6 _endasm;
	}
	
	if(clk & 0x02) {
		_asm BSF ADCON0, 7 _endasm;
	} else {
		_asm BCF ADCON0, 7 _endasm;
	}

	if(clk & 0x04) {
		_asm BSF ADCON1, 6 _endasm;
	} else {
		_asm BCF ADCON1, 6 _endasm;
	}
}

// please no channel > 7
void adc_set_channel(unsigned char channel) {
//	ADCON0 = (ADCON0 & BIN(11000111)) | (channel << 3);
	unsigned char tmp;
	channel <<= 3;
	tmp = ADCON0;
	tmp &= BIN(11000111);
	tmp |= channel;
	ADCON0 = tmp;
}

// start a conversion
void adc_start() {
	_asm
	BSF ADCON0, 0x2;
	_endasm;
}

// control which pins are analog, which are digital and if voltage
//  reference are pins on port a or Vdd, Vss?
void adc_set_port_config(unsigned char PCFG) {
	ADCON1 = (ADCON1 & 0xF0) | PCFG;
}

// TODO: create function to select between left and right justified data

// read an integer from the adc.  currently assumes right justified data
unsigned int adc_read_int() {
	unsigned int ret, tmp;
	ret = ADRESH;
	ret <<= 2;
	tmp = ADRESL;
	tmp >>= 6;
	return ret | tmp;
}

// computation, loops, the brains

// initialize data (per reading)
void init_data() {
	total_cnt = 0;
	total1 = 0;
	voltage_max = 0;
	current_max = 0;
}

// where is the sweep pot at?
unsigned char read_sweep() {
	int ret;
	
	adc_set_port_config(BIN(0000));
//	ADCON1 = BIN(01000000);

	adc_set_channel(5);
	delay(20);
	
	adc_start();
	adc_wait();

	ret = adc_read_int();
	ret >>= 3;
	
	return ret;
}

// read the position of the mode knob
unsigned char read_mode() {
	unsigned char mode;
	
	adc_set_port_config(BIN(0000));
//	ADCON1 = BIN(01000000);

	adc_set_channel(6);
//	ADCON0 = BIN(10110001);
	delay(20);
		
	adc_start();
//	ADCON0 = BIN(10110101);
	adc_wait();

	mode = ADRESH >> 5;
	
	return mode;
}

// retreive a single sample.
void get_data() {
	unsigned char neg;

	adc_set_port_config(BIN(1000));
//	ADCON1 = BIN(01001000);

	adc_set_channel(0);
//	ADCON0 = BIN(10000001);
	// wait for the channel to aquire the voltage
	delay(10);
	
	adc_start();
//	ADCON0 = BIN(10000101);
	adc_wait();
	
	adc_set_channel(1);
//	ADCON0 = BIN(10001001);
	
	// read channel 0
	voltage = adc_read_int();
	
//	TODO: why do these do different things?
//	adc_start();
	ADCON0 = BIN(10001101);
	adc_wait();

	adc_set_channel(4);

	// read channel 1
	reference = adc_read_int();

	ADCON0 = BIN(10100101);
	//adc_start();
	adc_wait();

	current = adc_read_int();

	// neg is used to keep track of the sign bit.  I've had problems
	// with the compiler and this was the easiest way to ensure that
	// everything worked.
	// 0 is positive
	// 1 is negative
	neg = 0;

	// TODO: why do I have to work around the problem like this?
	// these two commented out lines show what the next two if blocks
	// do.  For some reason, these aren't the same.  I think it has
	// something to do with how different data types are handled.
	// especially when two different data types are used in an
	// arithmatic operation.
//	current_diff = current - reference;
//	voltage_diff = voltage - reference;
	if(current > reference) {
		current_diff = current - reference;
	} else {
		current_diff = reference - current;
		neg = 1;
	}

	if(voltage > reference) {
		voltage_diff = voltage - reference;
	} else {
		voltage_diff = reference - voltage;
		neg ^= 1;
	}

	// using the mode output values for temp variables
	// useful for debuging
	// total1 = total1 + current_diff*current_diff;
	mode1 = current_diff;
	mode2 = voltage_diff;
	mode4 = mode1 * mode2;
	mode6 = current_diff * voltage_diff;
	if(neg) {
		total1 = total1 - mode4;
	} else {
		total1 = total1 + mode4;
	}

	++total_cnt;
}

// this is run once every reading, currently 256 samples
void analysis() {
	mode8 = total1/total_cnt;
	if(mode8 > 10000000) {
		mode8 = 0;
	}
	mode7 = mode8;
	// update moving average
	// moving_avg[i] is the most recent sample, moving_avg[i+1] is the oldest;
	//  unless i+1 == MOVING_AVG_SIZE at which point moving_avg[0] is the oldest
	// after each sample:
	//    subtract out the oldest from the total
	//    add in the newest
	//    remember the newest so it can be subtracted when it is the oldest
	//    calculate new average
	++moving_avg_i;
	if(moving_avg_i >= MOVING_AVG_SIZE) {
		moving_avg_i = 0;
	}
	moving_avg_total -= moving_avg[moving_avg_i];
	moving_avg_total += mode8;
	moving_avg[moving_avg_i] = mode8;
	mode8 = moving_avg_total / MOVING_AVG_SIZE;
	// calibrate
	mode8 *= 1000;
	mode8 /= CALIBRATION_SCALE;
	mode8 += CALIBRATION_OFFSET;
}

void main() {
	int i = 0;
	unsigned char neg = 0;		// true/1 when the last sample was negative (voltage < reference) 
	unsigned char sweep = 0;
	unsigned char mode;
	
	// no interupts
	INTCON = 0;

	// setup in/out ports
	TRISA = 255;
	TRISB = 0;
	TRISC = 0;
	TRISD = 0;

	// turn on and configure adc
//	ADCON0 = BIN(10000000);
	adc_set_clock(0x2);
	adc_on();

	// initialize the moving average data
	for(i = 0; i < MOVING_AVG_SIZE; ++i) {
		moving_avg[i] = 0;
	}

	// each iteration of the while loop is a single reading of data:
	//   256 samples
	//   analysis
	//   update display
	while(1) {
		init_data();
		mode = read_mode();
		sweep = read_sweep();
		
		// wait for a zero crossing on the voltage line.  Helps stabalize results
		// and makes debugging easier
		neg = 0;
		while(1) {
			// Count the next get_data if we break this time
			init_data();
			get_data();
			if(voltage < reference) {
				neg = 1;
			} else if (neg) {
				break;
			}
		}

		// read in 256 samples of data
		for(i = 1; i < 256; ++i) {
			get_data();
			if(sweep == i) {
//				mode5 = sweep;
//				mode6 = voltage_diff;
//				mode7 = current_diff;
			}
			// every 4 samples, turn on the next digit in the display
			// we must interleave this because the display needs to refresh
			// often and we want it to happen at the same point in the cycle
			// every time to keep results consistent.
			if(i & 4) {
				neg = i;
				neg >>= 3;
				neg = neg & 0x03;
				neg += 1;
				disp_dig(neg);
			}
		}

		// analyse the past 256 samples
		analysis();

		// depending on what mode we are in, display one of the values created in the
		// analysis.
		// TODO: rework this framework so that the analysis simply only generates the data
		// required to output the selected information.
		// might still leave some from of this in here for debuging.  Was extremely useful!
		switch (mode) {
			case 0 :
				disp_set_num(mode1);
				break;
			case 1 :
				disp_set_num(mode2);
				break;
			case 2 :
				disp_set_num(mode3);
				break;
			case 3 :
				disp_set_num(mode4);
				break;
			case 4 :
				disp_set_num(mode5);
				break;
			case 5 :
				disp_set_num(mode6);
				break;
			case 6 :
				disp_set_num(mode7);
				break;
			default :
				disp_set_num(mode8);
				break;
		}
		
		// update the kilo-LED
		disp_kilo();
	}
}
